//
// Copyright (c) 2018 [n/a] info@embeddora.com All rights reserved
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//        * Redistributions of source code must retain the above copyright
//          notice, this list of conditions and the following disclaimer.
//        * Redistributions in binary form must reproduce the above copyright
//          notice, this list of conditions and the following disclaimer in the
//          documentation and/or other materials provided with the distribution.
//        * Neither the name of The Linux Foundation nor
//          the names of its contributors may be used to endorse or promote
//          products derived from this software without specific prior written
//          permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Abstract:            an implementation of 'Shellcode' class
//
// Usage:               none
//
// Version:             0.0.8

// Definition of 'std::ifstream'
#include <fstream>

// Definition of 'std::search'
#include <algorithm>


// Definition of 'Shellcode' type, which is a C++ class
#include "exploit.hpp"

// Include all possible exploits 
#include "exploit.any"

///	\brief		A constructor of 'Exploit' class
///	\author		kmauch@
///	\version	0.1
///	\date		2018-03-14
///	\warning	Is not a subject for further optimization
///
///	@param[in]	none
///
///	@return		none
///
///	An auxiliary function, could be removed upon optimization
Exploit::Exploit(): Hazent("exploits")
{
	// Put known initilized strings into 'ha_exploit'
	setVectorData();

} // Exploit::Exploit()

///	\brief		A destructor of 'Exploit' class
///	\author		kmauch@
///	\version	0.1
///	\date		2018-03-14
///	\warning	Is not a subject for further optimization
///
///	@param[in]	none
///
///	@return		none
///
///	An auxiliary function, could be removed upon optimization
Exploit::~Exploit()
{
	// Dispose memory allocated by patterns, etc. Kept here for future implementations

} // Exploit::~Exploit()

///	\brief		Check if 'ar2' (of length 'size2') is present in 'ar1' (of size1). Returns true if present, and false by default 
///	\author		kmauch@
///	\version	0.1
///	\date		2018-03-14
///	\warning	Is not a subject for further optimization
///
///	@param[in]	ar1	First array to check
///	@param[in]	size1	Length of first array
///	@param[in]	ar2	Second array to check
///	@param[in]	size2	Length of second array
///
///	@return		Returns result of comparison
///
///	An auxiliary function, could be removed after debug is done
bool Exploit::isIthExploitContainedAsIs(char pcMemblock[], int iSize, int iIdx)
{
#if (0)

	// If 'is not present' return false
	return false;
#else
	// Check if range found is exactly the second range 
	return	std::search(	pcMemblock,				
				pcMemblock + iSize,
				ha_exploit  [iIdx].gExploit.c_str(), 
				ha_exploit  [iIdx].gExploit.c_str() + ha_exploit  [iIdx].iLength)
				!=
			(pcMemblock + iSize);
#endif // (0) } // bool isContained ( . . .)
}

///	\brief		Check if explot with index 'iIdx' is present in 'pcMemblock' of 'iSize'. Returns true if present, and false by default 
///	\author		kmauch@
///	\version	0.1
///	\date		2018-03-15
///	\warning	A subject for further optimization
///
///	@param[in]	pcMemblock	First array to check
///	@param[in]	iSize		Length of first array
///	@param[in]	iIdx		index of pattern to find
///
///
///	@return		Returns result of comparison
///
///	A basic function, should not be removed
bool Exploit::isIthContained(char pcMemblock[], int iSize, int iIdx)
{
	// Check if range found is exactly the second range 
	return	isIthExploitContainedAsIs(pcMemblock, iSize, iIdx);

} // bool Hazent::isIthContained(char pcMemblock[], int iSize, int iIdx)

///	\brief		A function to enroll patterns into empty vector variable
///	\author		kmauch@
///	\version	0.1
///	\date		2018-03-07
///	\warning	No optimizable
///
///	@param[in]	none
///
///	@return		none
///
///	A basic function, should not be removed
void Exploit::setVectorData()
{
	//Push back new object created with default constructor.
	ha_exploit.push_back ( _hazentry () );
	ha_exploit[0].gExploit = SE_M1;
	ha_exploit[0].iLength = SE_M1.length();

	//Add a new element
	ha_exploit.push_back ( _hazentry () );
	ha_exploit[1].gExploit = SE_M2;
	ha_exploit[1].iLength = SE_M2.length();

	//Add a new element
	ha_exploit.push_back ( _hazentry () );
	ha_exploit[2].gExploit = SE_M3;
	ha_exploit[2].iLength = SE_M3.length();

	//Add a new element
	ha_exploit.push_back ( _hazentry () );
	ha_exploit[3].gExploit = SE_M3;
	ha_exploit[3].iLength = SE_M3.length();

	//Add a new element
	ha_exploit.push_back ( _hazentry () );
	ha_exploit[4].gExploit = SE_M4;
	ha_exploit[4].iLength = SE_M4.length();

	//Add a new element
	ha_exploit.push_back ( _hazentry () );
	ha_exploit[5].gExploit = SE_M5;
	ha_exploit[5].iLength = SE_M5.length();

	//Add a new element
	ha_exploit.push_back ( _hazentry () );
	ha_exploit[6].gExploit = SE_M6;
	ha_exploit[6].iLength = SE_M6.length();

	//Add a new element
	ha_exploit.push_back ( _hazentry () );
	ha_exploit[7].gExploit = SE_M7;
	ha_exploit[7].iLength = SE_M7.length();

	//Add a new element
	ha_exploit.push_back ( _hazentry () );
	ha_exploit[8].gExploit = SE_M8;
	ha_exploit[8].iLength = SE_M8.length();

	//Add a new element
	ha_exploit.push_back ( _hazentry () );
	ha_exploit[9].gExploit = SE_M9;
	ha_exploit[9].iLength = SE_M9.length();

	//Add a new element
	ha_exploit.push_back ( _hazentry () );
	ha_exploit[10].gExploit = SE_M10;
	ha_exploit[10].iLength = SE_M10.length();

	//Add a new element
	ha_exploit.push_back ( _hazentry () );
	ha_exploit[11].gExploit = SE_M11;
	ha_exploit[11].iLength = SE_M11.length();

	//Add a new element
	ha_exploit.push_back ( _hazentry () );
	ha_exploit[12].gExploit = SE_M12;
	ha_exploit[12].iLength = SE_M12.length();

} // void setData(std::vector<_pattern> vec_pattern)
